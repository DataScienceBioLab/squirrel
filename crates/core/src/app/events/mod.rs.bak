//! Event system for the Squirrel project
//!
//! This module provides the event system functionality, which allows
//! different components of the system to communicate through events.
//! Events can be emitted, handled, and processed by various parts of the system.

use std::fmt;
use serde::{Serialize, Deserialize};
use time::OffsetDateTime;
use async_trait::async_trait;
use std::sync::Arc;
use std::collections::HashMap;
use tokio::sync::RwLock;
use std::fmt::Debug;
use serde_json::Value;
use std::future::Future;
use std::pin::Pin;
use thiserror::Error;
use uuid;

#[derive(Error, Debug)]
pub enum EventError {
    #[error("Invalid event type: {0}")]
    InvalidType(String),
    #[error("Event handler error: {0}")]
    HandlerError(String),
}

pub type Result<T> = std::result::Result<T, EventError>;

/// Event types supported by the system
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub enum EventType {
    SystemStartup,
    SystemShutdown,
    MetricCollected,
    AlertTriggered,
    HealthCheckCompleted,
}

impl std::str::FromStr for EventType {
    type Err = EventError;

    fn from_str(s: &str) -> Result<Self> {
        match s.to_lowercase().as_str() {
            "system" => Ok(Self::SystemStartup),
            "command" => Ok(Self::MetricCollected),
            "state" => Ok(Self::HealthCheckCompleted),
            "error" => Ok(Self::AlertTriggered),
            "warning" => Ok(Self::SystemShutdown),
            "info" => Ok(Self::MetricCollected),
            "debug" => Ok(Self::HealthCheckCompleted),
            "trace" => Ok(Self::SystemShutdown),
            _ => Err(EventError::InvalidType(s.to_string())),
        }
    }
}

/// Event data that can be attached to an event
pub enum EventData {
    /// String data
    String(String),
    /// JSON data
    Json(Value),
    /// Binary data
    Binary(Vec<u8>),
}

/// An event in the system
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Event {
    pub id: String,
    pub event_type: EventType,
    pub metadata: EventMetadata,
    pub payload: Value,
}

/// Builder for creating new events
pub struct EventBuilder {
    event_type: EventType,
    data: Value,
    metadata: EventMetadata,
}

impl Event {
    /// Create a new event builder
    pub fn builder() -> EventBuilder {
        EventBuilder::new()
    }

    /// Get the event type
    pub fn event_type(&self) -> &EventType {
        &self.event_type
    }

    /// Get the timestamp
    pub fn timestamp(&self) -> OffsetDateTime {
        self.metadata.timestamp
    }

    /// Get the data
    pub fn data(&self) -> &Value {
        &self.payload
    }

    /// Get the metadata
    pub fn metadata(&self) -> &EventMetadata {
        &self.metadata
    }

    pub fn new(
        event_type: EventType,
        payload: Value,
        metadata: Option<HashMap<String, String>>,
    ) -> Self {
        let mut event_metadata = EventMetadata::new();
        
        if let Some(labels) = metadata {
            event_metadata.labels = labels;
        }
        
        Self {
            id: uuid::Uuid::new_v4().to_string(),
            event_type,
            payload,
            metadata: event_metadata,
        }
    }

    #[must_use]
    pub fn with_metadata(mut self, metadata: EventMetadata) -> Self {
        self.metadata = metadata;
        self
    }

    #[must_use]
    pub fn with_correlation_id(mut self, correlation_id: String) -> Self {
        self.metadata.correlation_id = Some(correlation_id);
        self
    }

    #[must_use]
    pub fn with_label(mut self, key: String, value: String) -> Self {
        self.metadata.labels.insert(key, value);
        self
    }
}

impl EventBuilder {
    /// Create a new event builder
    pub fn new() -> Self {
        Self {
            event_type: EventType::SystemStartup,
            data: Value::Null,
            metadata: EventMetadata::new(),
        }
    }

    /// Set the event type
    #[must_use]
    pub fn event_type(mut self, event_type: EventType) -> Self {
        self.event_type = event_type;
        self
    }

    /// Set the data
    #[must_use]
    pub fn data(mut self, data: Value) -> Self {
        self.data = data;
        self
    }

    /// Set the metadata
    #[must_use]
    pub fn metadata(mut self, metadata: EventMetadata) -> Self {
        self.metadata = metadata;
        self
    }

    /// Set the correlation ID
    pub fn with_correlation_id(mut self, correlation_id: String) -> Self {
        self.metadata.correlation_id = Some(correlation_id);
        self
    }

    /// Add a label to the metadata
    pub fn with_label(mut self, key: String, value: String) -> Self {
        self.metadata.labels.insert(key, value);
        self
    }

    /// Build the event
    pub fn build(self) -> Event {
        Event {
            id: uuid::Uuid::new_v4().to_string(),
            event_type: self.event_type,
            payload: self.data,
            metadata: self.metadata,
        }
    }
}

impl Default for EventBuilder {
    fn default() -> Self {
        Self::new()
    }
}

impl fmt::Display for EventType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            EventType::SystemStartup => write!(f, "System Startup"),
            EventType::SystemShutdown => write!(f, "System Shutdown"),
            EventType::MetricCollected => write!(f, "Metric Collected"),
            EventType::AlertTriggered => write!(f, "Alert Triggered"),
            EventType::HealthCheckCompleted => write!(f, "Health Check Completed"),
        }
    }
}

impl fmt::Display for EventData {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            EventData::String(s) => write!(f, "String({s})"),
            EventData::Json(j) => write!(f, "Json({j})"),
            EventData::Binary(b) => write!(f, "Binary({} bytes)", b.len()),
        }
    }
}

impl fmt::Display for Event {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(
            f,
            "Event {{ id: {}, type: {}, timestamp: {} }}",
            self.id, self.event_type, self.metadata.timestamp
        )
    }
}

pub trait EventProcessor: Send + Sync {
    fn as_async(&self) -> &dyn EventProcessorAsync;
}

/// Event processor for asynchronous event processing
pub trait EventProcessorAsync: Send + Sync {
    /// Process an event
    ///
    /// # Errors
    ///
    /// Returns an `EventError` if the processing fails, which can occur due to:
    /// - Invalid event data
    /// - Processing logic failure
    /// - Resource unavailability
    fn process<'a>(&'a self, event: &'a Event) -> Pin<Box<dyn Future<Output = std::result::Result<(), EventError>> + Send + 'a>>;
}

/// Event bus for managing events
pub struct EventBus {
    events: Arc<RwLock<Vec<Event>>>,
    #[allow(clippy::type_complexity)]
    subscribers: Arc<RwLock<Vec<Box<dyn Fn(&Event) + Send + Sync>>>>,
}

impl Debug for EventBus {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("EventBus")
            .field("events", &self.events)
            .field("subscribers", &format!("<{count} subscribers>", count = self.subscribers.blocking_read().len()))
            .finish()
    }
}

impl EventBus {
    pub fn new() -> Self {
        Self {
            events: Arc::new(RwLock::new(Vec::new())),
            subscribers: Arc::new(RwLock::new(Vec::new())),
        }
    }

    pub async fn publish(&self, event: Event) -> Result<()> {
        let mut events = self.events.write().await;
        events.push(event.clone());
        
        let subscribers = self.subscribers.read().await;
        for subscriber in subscribers.iter() {
            subscriber(&event);
        }
        
        Ok(())
    }

    pub async fn subscribe<F>(&self, handler: F) -> Result<()>
    where
        F: Fn(&Event) + Send + Sync + 'static,
    {
        let mut subscribers = self.subscribers.write().await;
        subscribers.push(Box::new(handler));
        Ok(())
    }

    pub async fn get_events(&self) -> Result<Vec<Event>> {
        let events = self.events.read().await;
        Ok(events.clone())
    }

    pub async fn clear_events(&self) -> Result<()> {
        let mut events = self.events.write().await;
        events.clear();
        Ok(())
    }
}

impl Default for EventBus {
    fn default() -> Self {
        Self::new()
    }
}

/// Initialize the event system
pub async fn initialize() -> Result<()> {
    // TODO: Initialize event system
    Ok(())
}

/// Shutdown the event system
pub async fn shutdown() -> Result<()> {
    // TODO: Cleanup event system resources
    Ok(())
}

/// Event metadata
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EventMetadata {
    pub timestamp: OffsetDateTime,
    pub correlation_id: Option<String>,
    pub labels: HashMap<String, String>,
}

impl EventMetadata {
    pub fn new() -> Self {
        Self {
            timestamp: OffsetDateTime::now_utc(),
            correlation_id: None,
            labels: HashMap::new(),
        }
    }
    
    pub fn with_correlation_id(mut self, correlation_id: String) -> Self {
        self.correlation_id = Some(correlation_id);
        self
    }
    
    pub fn with_label(mut self, key: String, value: String) -> Self {
        self.labels.insert(key, value);
        self
    }
}

impl Default for EventMetadata {
    fn default() -> Self {
        Self::new()
    }
}

/// Event handler trait for processing events
#[async_trait]
pub trait EventHandler: Send + Sync + Debug {
    async fn handle(&self, event: Event) -> Result<()>;
}

#[derive(Debug, Default)]
pub struct EventEmitterConfig {
    pub max_events: usize,
    pub buffer_size: usize,
}

#[async_trait]
pub trait EventEmitter: Send + Sync {
    async fn emit(&self, event: Event) -> Result<()>;
}

/// Default implementation of the EventEmitter trait
#[derive(Debug)]
pub struct DefaultEventEmitter {
    handlers: Arc<RwLock<Vec<Box<dyn EventHandler + Send + Sync>>>>,
}

impl DefaultEventEmitter {
    pub fn new() -> Self {
        Self {
            handlers: Arc::new(RwLock::new(Vec::new())),
        }
    }
    
    pub async fn register_handler<H>(&self, handler: H) -> Result<()>
    where
        H: EventHandler + Send + Sync + 'static,
    {
        let mut handlers = self.handlers.write().await;
        handlers.push(Box::new(handler));
        Ok(())
    }
}

#[async_trait]
impl EventEmitter for DefaultEventEmitter {
    async fn emit(&self, event: Event) -> Result<()> {
        let handlers = self.handlers.read().await;
        for handler in handlers.iter() {
            handler.handle(event.clone()).await?;
        }
        Ok(())
    }
}

impl Default for DefaultEventEmitter {
    fn default() -> Self {
        Self::new()
    }
}

/// Default implementation of the `EventEmitter` trait
#[derive(Debug)]
pub struct DefaultEventEmitter {
    handlers: Arc<RwLock<Vec<Box<dyn EventHandler + Send + Sync>>>>,
}

impl DefaultEventEmitter {
    pub fn new() -> Self {
        Self {
            handlers: Arc::new(RwLock::new(Vec::new())),
        }
    }
    
    pub async fn register_handler<H>(&self, handler: H) -> Result<()>
    where
        H: EventHandler + Send + Sync + 'static,
    {
        let mut handlers = self.handlers.write().await;
        handlers.push(Box::new(handler));
        Ok(())
    }
}

#[async_trait]
impl EventEmitter for DefaultEventEmitter {
    async fn emit(&self, event: Event) -> Result<()> {
        let handlers = self.handlers.read().await;
        for handler in handlers.iter() {
            handler.handle(event.clone()).await?;
        }
        Ok(())
    }
}

impl Default for DefaultEventEmitter {
    fn default() -> Self {
        Self::new()
    }
} 