---
description: 
globs: 
alwaysApply: false
---
---
description: ENFORCE proper dependency injection patterns in Rust code to avoid global singletons
globs: ["**/*.rs"]
---

# Rust Singleton to Dependency Injection Conversion Standards

## Context
- When designing new Rust components
- When refactoring existing singleton patterns
- When implementing testable components
- When managing component dependencies
- When writing integration tests

## Requirements

### Component Structure
- Use adapter pattern for backward compatibility:
```rust
pub struct ComponentAdapter {
    inner: Option<Arc<Component>>,
}

impl ComponentAdapter {
    pub fn new() -> Self {
        Self { inner: None }
    }

    pub fn with_component(component: Arc<Component>) -> Self {
        Self {
            inner: Some(component),
        }
    }
}
```

### Factory Pattern
- Implement factory for component creation:
```rust
pub struct ComponentFactory {
    config: ComponentConfig,
}

impl ComponentFactory {
    pub fn new(config: ComponentConfig) -> Self {
        Self { config }
    }

    pub fn create_with_dependencies(
        &self,
        dep1: Arc<Dep1>,
        dep2: Arc<Dep2>,
    ) -> Arc<Component> {
        Arc::new(Component::with_dependencies(
            self.config.clone(),
            dep1,
            dep2,
        ))
    }

    pub fn create_adapter(&self) -> Arc<ComponentAdapter> {
        let component = self.create_with_dependencies();
        Arc::new(ComponentAdapter::with_component(component))
    }
}
```

### Dependency Injection
- Accept dependencies through constructors:
```rust
impl Component {
    pub fn with_dependencies(
        config: ComponentConfig,
        dep1: Arc<Dep1>,
        dep2: Arc<Dep2>,
    ) -> Self {
        Self {
            config,
            dep1,
            dep2,
        }
    }
}
```

### Testing Support
- Provide mock implementations:
```rust
#[cfg(test)]
mock! {
    pub Component {
        fn operation(&self) -> Result<()>;
    }
}

#[cfg(test)]
fn create_test_component() -> (Component, MockDep1, MockDep2) {
    let mock_dep1 = MockDep1::new();
    let mock_dep2 = MockDep2::new();
    
    let component = Component::with_dependencies(
        TestConfig::default(),
        Arc::new(mock_dep1.clone()),
        Arc::new(mock_dep2.clone()),
    );
    
    (component, mock_dep1, mock_dep2)
}
```

### Backward Compatibility
- Maintain global access through adapter:
```rust
impl ComponentAdapter {
    pub async fn operation(&self) -> Result<()> {
        if let Some(component) = &self.inner {
            component.operation().await
        } else {
            // Try to initialize on-demand
            match ensure_factory().get_global_component().await {
                Ok(component) => component.operation().await,
                Err(e) => Err(e),
            }
        }
    }
}
```

## Examples

### Good: Proper DI Implementation
```rust
// Component definition
pub struct MetricCollector {
    config: MetricConfig,
    storage: Arc<dyn MetricStorage>,
}

impl MetricCollector {
    pub fn with_dependencies(
        config: MetricConfig,
        storage: Arc<dyn MetricStorage>,
    ) -> Self {
        Self { config, storage }
    }
}

// Factory implementation
pub struct MetricCollectorFactory {
    config: MetricConfig,
}

impl MetricCollectorFactory {
    pub fn create_collector_with_storage(
        &self,
        storage: Arc<dyn MetricStorage>,
    ) -> Arc<MetricCollector> {
        Arc::new(MetricCollector::with_dependencies(
            self.config.clone(),
            storage,
        ))
    }
}

// Usage
let storage = Arc::new(RedisMetricStorage::new());
let collector = factory.create_collector_with_storage(storage);
```

### Bad: Global Singleton
```rust
// Bad: Global state
static COLLECTOR: OnceCell<Arc<MetricCollector>> = OnceCell::new();

// Bad: Global access
pub fn get_collector() -> Arc<MetricCollector> {
    COLLECTOR.get().unwrap().clone()
}

// Bad: Hidden dependencies
impl MetricCollector {
    pub fn new() -> Self {
        let storage = get_global_storage();
        Self { storage }
    }
}
```

## Best Practices
1. Use explicit dependency injection
2. Implement adapter pattern for legacy code
3. Create factories for component creation
4. Support mocking in tests
5. Document dependencies clearly
6. Avoid hidden global state
7. Use Arc for shared ownership
8. Implement proper error handling
9. Support async operations
10. Maintain backward compatibility

## Technical Metadata
- Category: Rust Patterns
- Priority: High
- Dependencies:
  - tokio = "1.0"
  - mockall = "0.11"
  - async-trait = "0.1"
- Testing Requirements:
  - Unit tests with mocks
  - Integration tests
  - Property tests
  - Stress tests

<version>1.0</version>